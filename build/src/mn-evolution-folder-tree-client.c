/* Generated by GOB (v2.0.15)   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 15

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "mn-evolution-folder-tree-client.h"

#include "mn-evolution-folder-tree-client-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 28 "src/mn-evolution-folder-tree-client.gob"

#include <glib/gi18n.h>
#include "mn-evolution-client-dbus.h"
#include "mn-dbus-properties-client-dbus.h"
#include "mn-evolution.h"
#include "mn-shell.h"
#include "mn-util.h"

#line 35 "mn-evolution-folder-tree-client.c"
/* self casting macros */
#define SELF(x) MN_EVOLUTION_FOLDER_TREE_CLIENT(x)
#define SELF_CONST(x) MN_EVOLUTION_FOLDER_TREE_CLIENT_CONST(x)
#define IS_SELF(x) MN_IS_EVOLUTION_FOLDER_TREE_CLIENT(x)
#define TYPE_SELF MN_TYPE_EVOLUTION_FOLDER_TREE_CLIENT
#define SELF_CLASS(x) MN_EVOLUTION_FOLDER_TREE_CLIENT_CLASS(x)

#define SELF_GET_CLASS(x) MN_EVOLUTION_FOLDER_TREE_CLIENT_GET_CLASS(x)

/* self typedefs */
typedef MNEvolutionFolderTreeClient Self;
typedef MNEvolutionFolderTreeClientClass SelfClass;

/* here are local prototypes */
static void ___object_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec);
static void ___object_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec);
#line 0 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_class_init (MNEvolutionFolderTreeClientClass * c);
#line 54 "mn-evolution-folder-tree-client.c"
#line 67 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_folder_activated (MNEvolutionFolderTreeClient * self);
#line 57 "mn-evolution-folder-tree-client.c"
#line 70 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_init (MNEvolutionFolderTreeClient * self);
#line 60 "mn-evolution-folder-tree-client.c"
#line 78 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_dispose (MNEvolutionFolderTreeClient * self);
#line 63 "mn-evolution-folder-tree-client.c"
#line 91 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_clear_proxy (MNEvolutionFolderTreeClient * self);
#line 66 "mn-evolution-folder-tree-client.c"
#line 116 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_update (MNEvolutionFolderTreeClient * self);
#line 69 "mn-evolution-folder-tree-client.c"
#line 148 "src/mn-evolution-folder-tree-client.gob"
static gboolean mn_evolution_folder_tree_client_plug_removed_h (GtkSocket * sock, gpointer user_data);
#line 72 "mn-evolution-folder-tree-client.c"
#line 158 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_realize_h (GtkWidget * widget, gpointer user_data);
#line 75 "mn-evolution-folder-tree-client.c"
#line 247 "src/mn-evolution-folder-tree-client.gob"
static gboolean mn_evolution_folder_tree_client_contact_error_cb (gpointer data);
#line 78 "mn-evolution-folder-tree-client.c"
#line 258 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_handle_contact_error (MNEvolutionFolderTreeClient * self);
#line 81 "mn-evolution-folder-tree-client.c"
#line 278 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_sync_selected_uri (MNEvolutionFolderTreeClient * self);
#line 84 "mn-evolution-folder-tree-client.c"
#line 308 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_set_widget (MNEvolutionFolderTreeClient * self, GtkWidget * widget);
#line 87 "mn-evolution-folder-tree-client.c"
#line 325 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_folder_selected_h (DBusGProxy * proxy, const char * uri, gpointer user_data);
#line 90 "mn-evolution-folder-tree-client.c"
#line 343 "src/mn-evolution-folder-tree-client.gob"
static void mn_evolution_folder_tree_client_folder_activated_h (DBusGProxy * proxy, gpointer user_data);
#line 93 "mn-evolution-folder-tree-client.c"

/*
 * Signal connection wrapper macro shortcuts
 */
#define self_connect__folder_activated(object,func,data)	mn_evolution_folder_tree_client_connect__folder_activated((object),(func),(data))
#define self_connect_after__folder_activated(object,func,data)	mn_evolution_folder_tree_client_connect_after__folder_activated((object),(func),(data))
#define self_connect_data__folder_activated(object,func,data,destroy_data,flags)	mn_evolution_folder_tree_client_connect_data__folder_activated((object),(func),(data),(destroy_data),(flags))

enum {
	FOLDER_ACTIVATED_SIGNAL,
	LAST_SIGNAL
};

enum {
	PROP_0,
	PROP_CONNECTED,
	PROP_SELECTED_URI
};

static guint object_signals[LAST_SIGNAL] = {0};

/* pointer to the class of our parent */
static GtkHBoxClass *parent_class = NULL;

/* Short form macros */
#define self_get_connected mn_evolution_folder_tree_client_get_connected
#define self_get_selected_uri mn_evolution_folder_tree_client_get_selected_uri
#define self_set_selected_uri mn_evolution_folder_tree_client_set_selected_uri
#define self_folder_activated mn_evolution_folder_tree_client_folder_activated
#define self_clear_proxy mn_evolution_folder_tree_client_clear_proxy
#define self_update mn_evolution_folder_tree_client_update
#define self_plug_removed_h mn_evolution_folder_tree_client_plug_removed_h
#define self_realize_h mn_evolution_folder_tree_client_realize_h
#define self_contact_error_cb mn_evolution_folder_tree_client_contact_error_cb
#define self_handle_contact_error mn_evolution_folder_tree_client_handle_contact_error
#define self_sync_selected_uri mn_evolution_folder_tree_client_sync_selected_uri
#define self_set_widget mn_evolution_folder_tree_client_set_widget
#define self_folder_selected_h mn_evolution_folder_tree_client_folder_selected_h
#define self_folder_activated_h mn_evolution_folder_tree_client_folder_activated_h
#define self_new mn_evolution_folder_tree_client_new
GType
mn_evolution_folder_tree_client_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (MNEvolutionFolderTreeClientClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) mn_evolution_folder_tree_client_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (MNEvolutionFolderTreeClient),
			0 /* n_preallocs */,
			(GInstanceInitFunc) mn_evolution_folder_tree_client_init,
			NULL
		};

		type = g_type_register_static (GTK_TYPE_HBOX, "MNEvolutionFolderTreeClient", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((MNEvolutionFolderTreeClient *)g_object_new(mn_evolution_folder_tree_client_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static MNEvolutionFolderTreeClient * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static MNEvolutionFolderTreeClient *
GET_NEW_VARG (const char *first, ...)
{
	MNEvolutionFolderTreeClient *ret;
	va_list ap;
	va_start (ap, first);
	ret = (MNEvolutionFolderTreeClient *)g_object_new_valist (mn_evolution_folder_tree_client_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static void
___dispose (GObject *obj_self)
{
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::dispose"
	MNEvolutionFolderTreeClient *self G_GNUC_UNUSED = MN_EVOLUTION_FOLDER_TREE_CLIENT (obj_self);
#line 78 "src/mn-evolution-folder-tree-client.gob"
	mn_evolution_folder_tree_client_dispose (self);
#line 184 "mn-evolution-folder-tree-client.c"
	if (G_OBJECT_CLASS (parent_class)->dispose) \
		(* G_OBJECT_CLASS (parent_class)->dispose) (obj_self);
}
#undef __GOB_FUNCTION__


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::finalize"
	MNEvolutionFolderTreeClient *self G_GNUC_UNUSED = MN_EVOLUTION_FOLDER_TREE_CLIENT (obj_self);
	gpointer priv G_GNUC_UNUSED = self->_priv;
	if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
#line 48 "src/mn-evolution-folder-tree-client.gob"
	if(self->selected_uri) { g_free ((gpointer) self->selected_uri); self->selected_uri = NULL; }
#line 201 "mn-evolution-folder-tree-client.c"
}
#undef __GOB_FUNCTION__

static void 
mn_evolution_folder_tree_client_class_init (MNEvolutionFolderTreeClientClass * c G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) c;

	g_type_class_add_private(c,sizeof(MNEvolutionFolderTreeClientPrivate));

	parent_class = g_type_class_ref (GTK_TYPE_HBOX);

	object_signals[FOLDER_ACTIVATED_SIGNAL] =
		g_signal_new ("folder_activated",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST),
			G_STRUCT_OFFSET (MNEvolutionFolderTreeClientClass, folder_activated),
			NULL, NULL,
			g_cclosure_marshal_VOID__VOID,
			G_TYPE_NONE, 0);

	c->folder_activated = NULL;
	g_object_class->dispose = ___dispose;
	g_object_class->finalize = ___finalize;
	g_object_class->get_property = ___object_get_property;
	g_object_class->set_property = ___object_set_property;
    {
	GParamSpec   *param_spec;

	param_spec = g_param_spec_boolean
		("connected" /* name */,
		 NULL /* nick */,
		 NULL /* blurb */,
		 FALSE /* default_value */,
		 (GParamFlags)(G_PARAM_READABLE));
	g_object_class_install_property (g_object_class,
		PROP_CONNECTED,
		param_spec);
	param_spec = g_param_spec_string
		("selected_uri" /* name */,
		 NULL /* nick */,
		 NULL /* blurb */,
		 NULL /* default_value */,
		 (GParamFlags)(G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (g_object_class,
		PROP_SELECTED_URI,
		param_spec);
    }
}
#undef __GOB_FUNCTION__
#line 70 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_init (MNEvolutionFolderTreeClient * self G_GNUC_UNUSED)
{
#line 257 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::init"
	self->_priv = G_TYPE_INSTANCE_GET_PRIVATE(self,MN_TYPE_EVOLUTION_FOLDER_TREE_CLIENT,MNEvolutionFolderTreeClientPrivate);
 {
#line 71 "src/mn-evolution-folder-tree-client.gob"

    selfp->client = mn_evolution_client_get();
    g_signal_connect_swapped(selfp->client, "notify::proxy", G_CALLBACK(self_update), self);

    self_update(self);
  
#line 268 "mn-evolution-folder-tree-client.c"
 }
}
#undef __GOB_FUNCTION__

static void
___object_set_property (GObject *object,
	guint property_id,
	const GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::set_property"
{
	MNEvolutionFolderTreeClient *self G_GNUC_UNUSED;

	self = MN_EVOLUTION_FOLDER_TREE_CLIENT (object);

	switch (property_id) {
	case PROP_SELECTED_URI:
		{
#line 51 "src/mn-evolution-folder-tree-client.gob"

      g_free(self->selected_uri);
      self->selected_uri = g_value_dup_string(VAL);

      if (selfp->proxy)
	self_sync_selected_uri(self);
    
#line 295 "mn-evolution-folder-tree-client.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__

static void
___object_get_property (GObject *object,
	guint property_id,
	GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::get_property"
{
	MNEvolutionFolderTreeClient *self G_GNUC_UNUSED;

	self = MN_EVOLUTION_FOLDER_TREE_CLIENT (object);

	switch (property_id) {
	case PROP_CONNECTED:
		{
#line 44 "src/mn-evolution-folder-tree-client.gob"

      g_value_set_boolean(VAL, selfp->proxy != NULL);
    
#line 328 "mn-evolution-folder-tree-client.c"
		}
		break;
	case PROP_SELECTED_URI:
		{
#line 59 "src/mn-evolution-folder-tree-client.gob"

      g_value_set_string(VAL, self->selected_uri);
    
#line 337 "mn-evolution-folder-tree-client.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__


#line 44 "src/mn-evolution-folder-tree-client.gob"
gboolean 
mn_evolution_folder_tree_client_get_connected (MNEvolutionFolderTreeClient * self)
{
#line 357 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::get_connected"
{
#line 42 "src/mn-evolution-folder-tree-client.gob"
		gboolean val; g_object_get (G_OBJECT (self), "connected", &val, NULL); return val;
}}
#line 363 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 59 "src/mn-evolution-folder-tree-client.gob"
gchar * 
mn_evolution_folder_tree_client_get_selected_uri (MNEvolutionFolderTreeClient * self)
{
#line 370 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::get_selected_uri"
{
#line 49 "src/mn-evolution-folder-tree-client.gob"
		gchar* val; g_object_get (G_OBJECT (self), "selected_uri", &val, NULL); return val;
}}
#line 376 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 51 "src/mn-evolution-folder-tree-client.gob"
void 
mn_evolution_folder_tree_client_set_selected_uri (MNEvolutionFolderTreeClient * self, gchar * val)
{
#line 383 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::set_selected_uri"
{
#line 49 "src/mn-evolution-folder-tree-client.gob"
		g_object_set (G_OBJECT (self), "selected_uri", val, NULL);
}}
#line 389 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 67 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_folder_activated (MNEvolutionFolderTreeClient * self)
{
#line 396 "mn-evolution-folder-tree-client.c"
	GValue ___param_values[1];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 67 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (self != NULL);
#line 67 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (MN_IS_EVOLUTION_FOLDER_TREE_CLIENT (self));
#line 407 "mn-evolution-folder-tree-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	g_signal_emitv (___param_values,
		object_signals[FOLDER_ACTIVATED_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
}


#line 78 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_dispose (MNEvolutionFolderTreeClient * self)
{
#line 426 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::dispose"
{
#line 79 "src/mn-evolution-folder-tree-client.gob"
	
    self_clear_proxy(self);

    mn_source_clear(&selfp->contact_error_idle_id);

    if (selfp->client)
      {
	g_signal_handlers_disconnect_by_func(selfp->client, self_update, self);
	selfp->client = NULL;
      }
  }}
#line 441 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 91 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_clear_proxy (MNEvolutionFolderTreeClient * self)
{
#line 448 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::clear_proxy"
#line 91 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (self != NULL);
#line 91 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (MN_IS_EVOLUTION_FOLDER_TREE_CLIENT (self));
#line 454 "mn-evolution-folder-tree-client.c"
{
#line 93 "src/mn-evolution-folder-tree-client.gob"
	
    if (selfp->proxy)
      {
	/*
	 * We cannot unreference the proxy because of a memory
	 * management bug in DBusGProxy
	 * (https://bugs.freedesktop.org/show_bug.cgi?id=14030), so
	 * simply disconnect the signals and nullify the proxy.
	 */

	dbus_g_proxy_disconnect_signal(selfp->proxy,
				       MN_EVOLUTION_FOLDER_TREE_SERVER_SIGNAL_FOLDER_SELECTED,
				       G_CALLBACK(self_folder_selected_h),
				       self);
	dbus_g_proxy_disconnect_signal(selfp->proxy,
				       MN_EVOLUTION_FOLDER_TREE_SERVER_SIGNAL_FOLDER_ACTIVATED,
				       G_CALLBACK(self_folder_activated_h),
				       self);

	mn_remove_weak_pointer(&selfp->proxy); /* also sets it to NULL */
      }
  }}
#line 479 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 116 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_update (MNEvolutionFolderTreeClient * self)
{
#line 486 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::update"
#line 116 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (self != NULL);
#line 116 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (MN_IS_EVOLUTION_FOLDER_TREE_CLIENT (self));
#line 492 "mn-evolution-folder-tree-client.c"
{
#line 118 "src/mn-evolution-folder-tree-client.gob"
	
    MNEvolutionClient *client;

    /*
     * We do not unconditionally create the GtkSocket to avoid the
     * widget change flicker that would occur if Evolution cannot be
     * contacted.
     */

    client = mn_evolution_client_get();
    if (client->proxy)
      {
	GtkWidget *sock;

	sock = gtk_socket_new();

	g_signal_connect(sock, "plug-removed", G_CALLBACK(self_plug_removed_h), NULL);

	/*
	 * In order to be able to call gtk_socket_get_id(), the socket
	 * must be added to a toplevel window.
	 */
	g_signal_connect(sock, "realize", G_CALLBACK(self_realize_h), self);

	self_set_widget(self, sock);
      }
    else
      self_handle_contact_error(self);
  }}
#line 524 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 148 "src/mn-evolution-folder-tree-client.gob"
static gboolean 
mn_evolution_folder_tree_client_plug_removed_h (GtkSocket * sock, gpointer user_data)
{
#line 531 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::plug_removed_h"
{
#line 150 "src/mn-evolution-folder-tree-client.gob"
	
    /*
     * Do not destroy the socket, it will be destroyed when removed
     * from the vbox in set_widget().
     */
    return TRUE;
  }}
#line 542 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 158 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_realize_h (GtkWidget * widget, gpointer user_data)
{
#line 549 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::realize_h"
{
#line 160 "src/mn-evolution-folder-tree-client.gob"
	
    Self *self = user_data;
    MNEvolutionClient *client;

    client = mn_evolution_client_get();
    if (client->proxy)
      {
	guint32 id;
	GError *err = NULL;

	id = (guint32) gtk_socket_get_id(GTK_SOCKET(widget));

	if (org_gnome_MailNotification_Evolution_folder_tree_new(client->proxy, id, &err))
	  {
	    char *service;
	    char *path;

	    self_clear_proxy(self);

	    service = g_strdup_printf(MN_EVOLUTION_FOLDER_TREE_SERVER_SERVICE, id);
	    path = g_strdup_printf(MN_EVOLUTION_FOLDER_TREE_SERVER_PATH, id);

	    selfp->proxy = dbus_g_proxy_new_for_name_owner(mn_shell->session_bus,
							   service,
							   path,
							   MN_EVOLUTION_FOLDER_TREE_SERVER_INTERFACE,
							   NULL);

	    g_free(service);
	    g_free(path);

	    if (selfp->proxy)
	      {
		/*
		 * We must add a weak pointer, so that if the proxy is
		 * destroyed after Evolution exits we won't try to
		 * clear an invalid proxy in clear_proxy().
		 */
		mn_add_weak_pointer(&selfp->proxy);

		selfp->properties_proxy = dbus_g_proxy_new_from_proxy(selfp->proxy, DBUS_INTERFACE_PROPERTIES, NULL);

		dbus_g_proxy_add_signal(selfp->proxy,
					MN_EVOLUTION_FOLDER_TREE_SERVER_SIGNAL_FOLDER_SELECTED,
					G_TYPE_STRING,	/* uri */
					G_TYPE_INVALID);
		dbus_g_proxy_add_signal(selfp->proxy,
					MN_EVOLUTION_FOLDER_TREE_SERVER_SIGNAL_FOLDER_ACTIVATED,
					G_TYPE_INVALID);

		dbus_g_proxy_connect_signal(selfp->proxy,
					    MN_EVOLUTION_FOLDER_TREE_SERVER_SIGNAL_FOLDER_SELECTED,
					    G_CALLBACK(self_folder_selected_h),
					    self,
					    NULL);
		dbus_g_proxy_connect_signal(selfp->proxy,
					    MN_EVOLUTION_FOLDER_TREE_SERVER_SIGNAL_FOLDER_ACTIVATED,
					    G_CALLBACK(self_folder_activated_h),
					    self,
					    NULL);

		/* give the folder tree a decent height */
		gtk_widget_set_size_request(widget, -1, 150);

		self_sync_selected_uri(self);
		g_object_notify(G_OBJECT(self), "connected");

		return;		/* success */
	      }
	  }
	else
	  {
	    /* unlikely to ever happen, not worth a translation */
	    g_warning("cannot create folder tree: %s", err->message);
	    g_error_free(err);
	  }
      }

    /*
     * Failure. We cannot call handle_contact_error() from here since
     * it would destroy the GtkSocket that is currently being
     * realized. Use an idle callback.
     */
    if (! selfp->contact_error_idle_id)
      selfp->contact_error_idle_id = gdk_threads_add_idle(self_contact_error_cb, self);
  }}
#line 639 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 247 "src/mn-evolution-folder-tree-client.gob"
static gboolean 
mn_evolution_folder_tree_client_contact_error_cb (gpointer data)
{
#line 646 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::contact_error_cb"
{
#line 249 "src/mn-evolution-folder-tree-client.gob"
	
    Self *self = data;

    self_handle_contact_error(self);

    selfp->contact_error_idle_id = 0;
    return FALSE;		/* remove source */
  }}
#line 658 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 258 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_handle_contact_error (MNEvolutionFolderTreeClient * self)
{
#line 665 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::handle_contact_error"
#line 258 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (self != NULL);
#line 258 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (MN_IS_EVOLUTION_FOLDER_TREE_CLIENT (self));
#line 671 "mn-evolution-folder-tree-client.c"
{
#line 260 "src/mn-evolution-folder-tree-client.gob"
	
    GtkWidget *label;

    if (selfp->proxy)
      {
	self_clear_proxy(self);
	g_object_notify(G_OBJECT(self), "connected");
      }

    label = gtk_label_new(_("Mail Notification can not contact Evolution. Make sure that Evolution is running and that the Evolution Jean-Yves Lefort's Mail Notification plugin is loaded."));

    gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
    gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);
    gtk_label_set_selectable(GTK_LABEL(label), TRUE);

    self_set_widget(self, label);
  }}
#line 691 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 278 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_sync_selected_uri (MNEvolutionFolderTreeClient * self)
{
#line 698 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::sync_selected_uri"
#line 278 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (self != NULL);
#line 278 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (MN_IS_EVOLUTION_FOLDER_TREE_CLIENT (self));
#line 704 "mn-evolution-folder-tree-client.c"
{
#line 280 "src/mn-evolution-folder-tree-client.gob"
	
    GValue value = { 0, };
    GError *err = NULL;

    g_return_if_fail(selfp->proxy != NULL);

    if (! self->selected_uri)
      return;

    g_value_init(&value, G_TYPE_STRING);
    g_value_set_string(&value, self->selected_uri);

    if (! org_freedesktop_DBus_Properties_set(selfp->properties_proxy,
					      MN_EVOLUTION_FOLDER_TREE_SERVER_INTERFACE,
					      MN_EVOLUTION_FOLDER_TREE_SERVER_PROPERTY_URI,
					      &value,
					      &err))
      {
	g_warning("cannot set D-Bus property %s of interface %s: %s",
		  MN_EVOLUTION_FOLDER_TREE_SERVER_PROPERTY_URI,
		  MN_EVOLUTION_FOLDER_TREE_SERVER_INTERFACE,
		  err->message);
	g_error_free(err);
      }

    g_value_unset(&value);
  }}
#line 734 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 308 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_set_widget (MNEvolutionFolderTreeClient * self, GtkWidget * widget)
{
#line 741 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::set_widget"
#line 308 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (self != NULL);
#line 308 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (MN_IS_EVOLUTION_FOLDER_TREE_CLIENT (self));
#line 308 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (widget != NULL);
#line 308 "src/mn-evolution-folder-tree-client.gob"
	g_return_if_fail (GTK_IS_WIDGET (widget));
#line 751 "mn-evolution-folder-tree-client.c"
{
#line 310 "src/mn-evolution-folder-tree-client.gob"
	
    GList *children;

    children = gtk_container_get_children(GTK_CONTAINER(self));
    if (children)
      {
	g_assert(g_list_length(children) == 1);
	gtk_container_remove(GTK_CONTAINER(self), children->data);
	g_list_free(children);
      }

    gtk_box_pack_start(GTK_BOX(self), widget, TRUE, TRUE, 0);
    gtk_widget_show(widget);
  }}
#line 768 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 325 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_folder_selected_h (DBusGProxy * proxy, const char * uri, gpointer user_data)
{
#line 775 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::folder_selected_h"
{
#line 329 "src/mn-evolution-folder-tree-client.gob"
	
    Self *self = user_data;

    /* this is a main loop callback */
    GDK_THREADS_ENTER();

    g_free(self->selected_uri);
    self->selected_uri = g_strdup(uri);

    g_object_notify(G_OBJECT(self), "selected-uri");

    GDK_THREADS_LEAVE();
  }}
#line 792 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 343 "src/mn-evolution-folder-tree-client.gob"
static void 
mn_evolution_folder_tree_client_folder_activated_h (DBusGProxy * proxy, gpointer user_data)
{
#line 799 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::folder_activated_h"
{
#line 345 "src/mn-evolution-folder-tree-client.gob"
	
    Self *self = user_data;

    /* this is a main loop callback */
    GDK_THREADS_ENTER();

    self_folder_activated(self);

    GDK_THREADS_LEAVE();
  }}
#line 813 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__

#line 356 "src/mn-evolution-folder-tree-client.gob"
GtkWidget * 
mn_evolution_folder_tree_client_new (void)
{
#line 820 "mn-evolution-folder-tree-client.c"
#define __GOB_FUNCTION__ "MN:Evolution:Folder:Tree:Client::new"
{
#line 358 "src/mn-evolution-folder-tree-client.gob"
	
    return GTK_WIDGET(GET_NEW);
  }}
#line 827 "mn-evolution-folder-tree-client.c"
#undef __GOB_FUNCTION__
